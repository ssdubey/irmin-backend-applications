open Lwt_main
open Bos_setup

(*Irmin exposes two Append_only and Atomic_write stores as modules to use the backend features*)
module Key_module = Irmin_memipfs.Atomic_write (Irmin.Contents.String) (Irmin.Contents.String)
module Store_module = Irmin_memipfs.Append_only (Irmin.Contents.String) (Irmin.Contents.String)


(*config can be made optional if we assume that ipfs in any machine will be present at a given location only and modify the 
commands in the backend*)
let ipfs = "/usr/local/bin/ipfs"
let config1 = Irmin_memipfs.config ipfs
let hashtable = Lwt_main.run @@ Store_module.v config1 
let key_hashtable = Lwt_main.run @@ Key_module.v config1 



(* set_key function takes the `key` provided by the user and the hash generated by the ipfs. This generated hash is the key which
IPFS would consider when looking for data into the network. set_key generates a publish key using the key provided by the user and 
further publish the data over this key.*)
let set_key key data_hash = 
  (*generate publish key, publish and set*)
  let pub_key = OS.Cmd.in_string ""
             |> OS.Cmd.run_io Cmd.(v ipfs % "key" % "gen" % "--type=rsa" % "--size=2048" % key) 
             |> OS.Cmd.to_string in   

  let pub_key = match pub_key with
  | Result.Ok hash-> hash
  | _ -> (let foundkey = Lwt_main.run @@ Key_module.find key_hashtable key in
          match foundkey with
          | None -> "invalidkey"
          | Some key -> key) in 

  let v1 = ("--key=" ^ key) in
  let v2 = ("/ipfs/" ^ data_hash) in
  let _ = OS.Cmd.in_string ""
  |> OS.Cmd.run_io Cmd.(v ipfs % "name" % "publish" % v1 % v2) 
  |> OS.Cmd.to_string in

  (*once the application ends, this table does not exist anymore, as it uses irmin-mem*)
  Key_module.set key_hashtable key pub_key



(*user can use add_data function to add `value` corresponding to each `key` into the ipfs. Since the key in 
ipfs is the hash generated based on the data itself, its use is not trivial. This complexity is handled in `set_key` function.*)
let add_data key value =
    let _ = Store_module.batch hashtable (fun hashtable -> Store_module.add hashtable key value ) in
    let data_hash = Irmin_memipfs.setkey in
     set_key key !data_hash
     (*set_key key value;; @testing*)


     
(*it fetches the key stored using irmin-mem. For a newly started application, it would be an empty table and does not return any value*)
let find_key key = 
  let foundkey = Lwt_main.run @@ Key_module.find key_hashtable key in
  
  let foundkey = match foundkey with
  | None -> "invalidkey"
  | Some key -> key in 

  let searchstring = ("/ipns/" ^ foundkey) in
  print_string searchstring;
  let catstring = OS.Cmd.in_string ""
                |> OS.Cmd.run_io Cmd.(v ipfs % "cat" % searchstring) 
                |> OS.Cmd.to_string in

  let str = match catstring with
  | Result.Ok str-> str
  | _ -> "" in         
  
  print_string ("\n" ^ str ^ "\n")